
            animation-duration: 35s;
            animation-delay: -10s;
        }
        
        @keyframes float {
            0%, 10
            z-index: 1000;
            padding: 1rem 2rem;
            background: rgba(10, 14, 23, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .navbar.scrolled {
            background: rgba(10, 14, 23, 0.95);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 800;
            font-size: 1.8rem;
        }
        
        .logo-icon {
            width: 45px;
            height: 45px;
            background: linear-gradient(135deg, #04e8a5, #03b886);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: glowPulse 2s ease-in-out infinite;
        }
        
        .logo-text {
            background: linear-gradient(135deg, #ffffff 40%, #04e8a5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textGradient 3s ease-in-out infinite;
            background-size: 200% 200%;
        }
                font-size: 2.2rem;
   
            
            // Trigger counter animation when stats are visible
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        animateCounters();
                        observer.unobserve(entry.target);
                    }
                });
            });
            
            const statsSection = document.querySelector('.hero-stats');
            if (statsSection) {
                observer.observe(statsSection);
            }
            
            // Handle scroll animations
            window.addEventListener('scroll', handleScrollAnimation);
            handleScrollAnimation(); // Check initial state
        });
        
        // Add parallax effect to orbs
        window.addEventListener('mousemove', (e) => {
            const orbs = document.querySelectorAll('.orb');
            const x = e.clientX / window.innerWidth;
            const y = e.clientY / window.innerHeight;
            
            orbs.forEach((orb, index) => {
                const speed = (index + 1) * 10;
                const xOffset = (x - 0.5) * speed;
                const yOffset = (y - 0.5) * speed;
                
                orb.style.transform = `translate(${xOffset}px, ${yOffset}p
        });
    </script>
</body>
</html>

